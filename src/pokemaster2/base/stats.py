"""Stats class."""
import math
import operator
import secrets
from decimal import Decimal
from typing import Callable, Type, TypeVar, Union

from attrs import define, field

STAT_NAMES = ["hp", "atk", "def_", "spa", "spd", "spe"]
STAT_NAMES_FULL = {
    "hp": "hp",
    "attack": "atk",
    "defense": "def_",
    "special-attack": "spa",
    "special-defense": "spd",
    "speed": "spe",
}

S = TypeVar("S", bound="Stats")
NumberLike = Union[S, int, float, Decimal]


def _to_decimal(number: Union[int, float, Decimal]) -> Decimal:
    """Convert a number to a Decimal.

    `float` needs to be converted to `str` first and then convert to `Decimal`, otherwise `Decimal`
    will include all decimals generated by the `float`.

    E.g., Decimal(2.1) => Decimal('2.100000000000000088817841970012523233890533447265625'), but
    Decimal('2.1') => Decimal('2.1')

    Args:
        number: A number representation.

    Returns:
        The converted `Decimal` representation of `number`.

    """
    return Decimal(str(number))


@define
class Stats:
    """Generic stats, can be used for Pokemon stats/IV/EV."""

    hp: Decimal = field(converter=_to_decimal, default=Decimal("0"))
    atk: Decimal = field(converter=_to_decimal, default=Decimal("0"))
    def_: Decimal = field(converter=_to_decimal, default=Decimal("0"))
    spa: Decimal = field(converter=_to_decimal, default=Decimal("0"))
    spd: Decimal = field(converter=_to_decimal, default=Decimal("0"))
    spe: Decimal = field(converter=_to_decimal, default=Decimal("0"))

    def __add__(self: S, other: NumberLike) -> S:
        """Pointwise addition."""
        return self._pointwise(operator.add, other)

    def __sub__(self: S, other: NumberLike) -> S:
        """Pointwise subtraction."""
        return self._pointwise(operator.sub, other)

    def __mul__(self: S, other: NumberLike) -> S:
        """Pointwise multiplication."""
        return self._pointwise(operator.mul, other)

    def __floordiv__(self: S, other: NumberLike) -> S:
        """Pointwise floor division."""
        return self._pointwise(operator.floordiv, other)

    __radd__ = __add__
    __rmul__ = __mul__

    def _pointwise(
        self: S,
        operator: Callable[[int, int], int],
        other: NumberLike,
    ) -> S:
        """Programmatically create point-wise operators.

        Args:
            operator: A callable (Real, Real) -> Real.
            other: If `other` is a `Stats` instance, then the
                operator will be applied point-wisely. If `other` is a
                number, then a scalar operation will be applied.

        Returns:
            A `Stats` instance.
        """
        result_stats = {}
        for stat in STAT_NAMES:
            if isinstance(other, type(self)):
                result_stats[stat] = Decimal(operator(getattr(self, stat), getattr(other, stat)))
            else:
                result_stats[stat] = Decimal(operator(getattr(self, stat), Decimal(str(other))))

        return self.__class__(**result_stats)

    def validate_iv(self: S) -> bool:
        """Check if each IV is between 0 and 31."""
        for stat in STAT_NAMES:
            if not 0 <= getattr(self, stat) <= 31:
                raise ValueError(
                    f"The {stat} IV ({getattr(self, stat)}) must be a number "
                    "between 0 and 31 inclusive."
                )
        return True

    @classmethod
    def iv(cls: Type[S], iv_index: int) -> S:
        """Create IV stats from a PokÃ©mon's DNA.

        Args:
            iv_index: An `int` generated by the DNA.

        Returns:
            A `Stats` instance.
        """
        return cls(
            hp=iv_index % 32,
            atk=(iv_index >> 5) % 32,
            def_=(iv_index >> 10) % 32,
            spe=(iv_index >> 16) % 32,
            spa=(iv_index >> 21) % 32,
            spd=(iv_index >> 26) % 32,
        )

    @classmethod
    def random_iv(cls: Type[S]) -> S:
        """Create random IV Stats."""
        return cls.iv(iv_index=secrets.randbelow(0xA00000000))

    @classmethod
    def same(cls: Type[S], value: int) -> S:
        """Create a Stats instance with all attributes the same value."""
        return cls(*[value for _ in range(6)])

    @classmethod
    def max_iv(cls: Type[S]) -> S:
        """Return a max IV."""
        return cls.same(31)

    @classmethod
    def zeros(cls: Type[S]) -> S:
        """Empty Stats."""
        return cls.same(0)

    @classmethod
    def random_base_stats(cls: Type[S]) -> S:
        """Return a random set of base stats."""
        return cls(*[max(1, math.ceil(secrets.randbelow(255))) for _ in range(6)])

    @classmethod
    def nature_modifiers(cls: Type[S], increase: str, decrease: str) -> S:
        """Generate nature modifier Stats."""
        nature_modifiers = dict(zip(STAT_NAMES, list("1" * 6)))
        nature_modifiers[increase] = 1.1
        nature_modifiers[decrease] = 0.9
        return cls(**nature_modifiers)

    @classmethod
    def calc(cls: Type[S], level: int, base_stats: S, iv: S, ev: S, nature_modifiers: S) -> S:
        """Calculate a Pokemon's permanent stats."""
        residual_stats = Stats(
            hp=10 + level,
            atk=5,
            def_=5,
            spa=5,
            spd=5,
            spe=5,
        )

        stats = (
            (base_stats * 2 + iv + ev // 4) * level // 100 + residual_stats
        ) * nature_modifiers
        if base_stats.hp == 1:
            stats.hp = 1
        return stats
