"""Stats class."""

import operator
from typing import Callable, Type, TypeVar, Union

import attr

from pokemaster2.prng import PRNG

S = TypeVar("S", bound="Stats")


STAT_NAMES = ["hp", "atk", "def_", "spatk", "spdef", "spd"]
STAT_NAMES_FULL = {
    "hp": "hp",
    "attack": "atk",
    "defense": "def_",
    "special-attack": "spatk",
    "special-defense": "spdef",
    "speed": "spd",
}

prng = PRNG()


@attr.s(auto_attribs=True)
class Stats:
    """Generic stats, can be used for Pokemon stats/IV/EV."""

    hp: int
    atk: int
    def_: int
    spatk: int
    spdef: int
    spd: int

    def __add__(self: S, other: Union[S, int]) -> S:
        """Pointwise addition."""
        return self._make_operator(operator.add, other)

    def __sub__(self: S, other: Union[S, int]) -> S:
        """Pointwise subtraction."""
        return self._make_operator(operator.sub, other)

    def __mul__(self: S, other: Union[S, int]) -> S:
        """Pointwise multiplication."""
        return self._make_operator(operator.mul, other)

    def __floordiv__(self: S, other: Union[S, int]) -> S:
        """Pointwise floor division."""
        return self._make_operator(operator.floordiv, other)

    __radd__ = __add__
    __rmul__ = __mul__

    def _make_operator(
        self: S,
        operator: Callable[[int, int], int],
        other: Union[S, int],
    ) -> S:
        """Programmatically create point-wise operators.

        Args:
            operator: A callable (Real, Real) -> Real.
            other: If `other` is a `Stats` instance, then the
                operator will be applied point-wisely. If `other` is a
                number, then a scalar operation will be applied.

        Raises:
            TypeError: `other` should be either another `Stats` or `int`.

        Returns:
            A `Stats` instance.
        """
        names = (
            "hp",
            "atk",
            "def_",
            "spatk",
            "spdef",
            "spd",
        )

        if not isinstance(other, type(self)) and not isinstance(other, int):
            raise TypeError(
                f"unsupported operand type(s) for {operator}: "
                f"'{type(self)}' and '{type(other)}'"
            )
        result_stats = {}
        for stat in names:
            if isinstance(other, type(self)):
                result_stats[stat] = int(operator(getattr(self, stat), getattr(other, stat)))
            elif isinstance(other, int):
                result_stats[stat] = int(operator(getattr(self, stat), other))
        return self.__class__(**result_stats)

    def validate_iv(self: S) -> bool:
        """Check if each IV is between 0 and 32."""
        for stat in STAT_NAMES:
            if not 0 <= getattr(self, stat) <= 32:
                raise ValueError(
                    f"The {stat} IV ({getattr(self, stat)}) must be a number "
                    "between 0 and 32 inclusive."
                )
        return True

    @classmethod
    def create_iv(cls: Type[S], gene: int) -> S:
        """Create IV stats from a PokÃ©mon's gene.

        Args:
            gene: An `int` generated by the PRNG.

        Returns:
            A `Stats` instance.
        """
        return cls(
            hp=gene % 32,
            atk=(gene >> 5) % 32,
            def_=(gene >> 10) % 32,
            spd=(gene >> 16) % 32,
            spatk=(gene >> 21) % 32,
            spdef=(gene >> 26) % 32,
        )

    @classmethod
    def max_iv(cls: Type[S]) -> S:
        """Return a max IV."""
        return cls(*[31 for _ in range(6)])

    @classmethod
    def zeros(cls: Type[S]) -> S:
        """Empty Stats."""
        return cls(
            hp=0,
            atk=0,
            def_=0,
            spatk=0,
            spdef=0,
            spd=0,
        )

    @classmethod
    def nature_modifiers(cls: Type[S], nature: str) -> S:
        """Generate nature modifier Stats."""
        # nature_data = _db.get_nature(identifier=nature)
        # modifiers = {}
        # for stat in STAT_NAMES:
        #     modifiers[stat] = 1
        # if nature_data.is_neutral:
        #     return cls(**modifiers)
        # modifiers[STAT_NAMES_FULL[nature_data.increased_stat.identifier]] = 1.1
        # modifiers[STAT_NAMES_FULL[nature_data.decreased_stat.identifier]] = 0.9
        # return cls(**modifiers)

    @classmethod
    def calc(cls: Type[S], level: int, base_stats: S, iv: S, ev: S, nature: str) -> S:
        """Calculate a Pokemon's permanent stats."""
        nature_modifiers = Stats.nature_modifiers(nature)
        residual_stats = Stats(
            hp=10 + level,
            atk=5,
            def_=5,
            spatk=5,
            spdef=5,
            spd=5,
        )

        stats = (
            (base_stats * 2 + iv + ev // 4) * level // 100 + residual_stats
        ) * nature_modifiers
        if base_stats.hp == 1:
            stats.hp = 1
        return stats
