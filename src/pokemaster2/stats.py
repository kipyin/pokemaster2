"""Stats class."""
import math
import operator
from decimal import Decimal
from typing import Callable, Type, TypeVar, Union

from attrs import define, field

from pokemaster2.prng import PRNG

STAT_NAMES = ["hp", "atk", "def_", "spa", "spd", "spe"]
STAT_NAMES_FULL = {
    "hp": "hp",
    "attack": "atk",
    "defense": "def_",
    "special-attack": "spa",
    "special-defense": "spd",
    "speed": "spe",
}

prng = PRNG()


S = TypeVar("S", bound="Stats")
N = TypeVar("N", bound="Nature")
NumberLike = Union[S, int, float, Decimal]


def _to_decimal(number: Union[int, float, Decimal]) -> Decimal:
    """Convert a number to a Decimal.

    `float` needs to be converted to `str` first and then convert to `Decimal`, otherwise `Decimal`
    will include all decimals generated by the `float`.

    E.g., Decimal(2.1) => Decimal('2.100000000000000088817841970012523233890533447265625'), but
    Decimal('2.1') => Decimal('2.1')

    Args:
        number: A number representation.

    Returns:
        The converted `Decimal` representation of `number`.

    """
    return Decimal(str(number))


@define
class Stats:
    """Generic stats, can be used for Pokemon stats/IV/EV."""

    hp: Decimal = field(converter=_to_decimal, default=Decimal("0"))
    atk: Decimal = field(converter=_to_decimal, default=Decimal("0"))
    def_: Decimal = field(converter=_to_decimal, default=Decimal("0"))
    spa: Decimal = field(converter=_to_decimal, default=Decimal("0"))
    spd: Decimal = field(converter=_to_decimal, default=Decimal("0"))
    spe: Decimal = field(converter=_to_decimal, default=Decimal("0"))

    def __add__(self: S, other: NumberLike) -> S:
        """Pointwise addition."""
        return self._make_operator(operator.add, other)

    def __sub__(self: S, other: NumberLike) -> S:
        """Pointwise subtraction."""
        return self._make_operator(operator.sub, other)

    def __mul__(self: S, other: NumberLike) -> S:
        """Pointwise multiplication."""
        return self._make_operator(operator.mul, other)

    def __floordiv__(self: S, other: NumberLike) -> S:
        """Pointwise floor division."""
        return self._make_operator(operator.floordiv, other)

    __radd__ = __add__
    __rmul__ = __mul__

    def _make_operator(
        self: S,
        operator: Callable[[int, int], int],
        other: NumberLike,
    ) -> S:
        """Programmatically create point-wise operators.

        Args:
            operator: A callable (Real, Real) -> Real.
            other: If `other` is a `Stats` instance, then the
                operator will be applied point-wisely. If `other` is a
                number, then a scalar operation will be applied.

        Returns:
            A `Stats` instance.
        """
        result_stats = {}
        for stat in STAT_NAMES:
            if isinstance(other, type(self)):
                result_stats[stat] = Decimal(operator(getattr(self, stat), getattr(other, stat)))
            else:
                result_stats[stat] = Decimal(operator(getattr(self, stat), Decimal(str(other))))

        return self.__class__(**result_stats)

    def validate_iv(self: S) -> bool:
        """Check if each IV is between 0 and 31."""
        for stat in STAT_NAMES:
            if not 0 <= getattr(self, stat) <= 31:
                raise ValueError(
                    f"The {stat} IV ({getattr(self, stat)}) must be a number "
                    "between 0 and 31 inclusive."
                )
        return True

    @classmethod
    def create_iv(cls: Type[S], gene: int) -> S:
        """Create IV stats from a Pokémon's gene.

        Args:
            gene: An `int` generated by the PRNG.

        Returns:
            A `Stats` instance.
        """
        return cls(
            hp=gene % 32,
            atk=(gene >> 5) % 32,
            def_=(gene >> 10) % 32,
            spe=(gene >> 16) % 32,
            spa=(gene >> 21) % 32,
            spd=(gene >> 26) % 32,
        )

    @classmethod
    def random_iv(cls: Type[S]) -> S:
        """Create random IV Stats."""
        pid, iv_gene = prng.generate_pid_and_iv(method=2)
        return cls.create_iv(gene=iv_gene)

    @classmethod
    def max_iv(cls: Type[S]) -> S:
        """Return a max IV."""
        return cls(*[31 for _ in range(6)])

    @classmethod
    def zeros(cls: Type[S]) -> S:
        """Empty Stats."""
        return cls(
            hp=0,
            atk=0,
            def_=0,
            spa=0,
            spd=0,
            spe=0,
        )

    @classmethod
    def random_base_stats(cls: Type[S]) -> S:
        """Return a random set of base stats."""
        return cls(*[max(1, math.ceil(prng.random() * 255)) for _ in range(6)])

    @classmethod
    def nature_modifiers(cls: Type[S], nature: str) -> S:
        """Generate nature modifier Stats."""
        # nature_data = _db.get_nature(identifier=nature)
        # modifiers = {}
        # for stat in STAT_NAMES:
        #     modifiers[stat] = 1
        # if nature_data.is_neutral:
        #     return cls(**modifiers)
        # modifiers[STAT_NAMES_FULL[nature_data.increased_stat.identifier]] = 1.1
        # modifiers[STAT_NAMES_FULL[nature_data.decreased_stat.identifier]] = 0.9
        # return cls(**modifiers)

    @classmethod
    def calc(cls: Type[S], level: int, base_stats: S, iv: S, ev: S, nature: N) -> S:
        """Calculate a Pokemon's permanent stats."""
        nature_modifiers = nature.modifiers
        residual_stats = Stats(
            hp=10 + level,
            atk=5,
            def_=5,
            spa=5,
            spd=5,
            spe=5,
        )

        stats = (
            (base_stats * 2 + iv + ev // 4) * level // 100 + residual_stats
        ) * nature_modifiers
        if base_stats.hp == 1:
            stats.hp = 1
        return stats


@define
class Nature:
    """A Pokémon's nature."""

    name: str
    increase: str
    decrease: str

    @property
    def modifiers(self: N) -> Stats:
        """Get the nature modifiers as a `Stats` instance."""
        nature_modifiers = dict(zip(STAT_NAMES, list("1" * 6)))
        nature_modifiers[self.increase] = 1.1
        nature_modifiers[self.decrease] = 0.9
        return Stats(**nature_modifiers)
